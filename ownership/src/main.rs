/*
由于计算机的内存是有限的，因此一个程序需要管理好内存，避免资源占用过高和内存泄漏

有些语言是有 gc 管理内存，例如 java/go
优点：程序员不用操行内存管理，适合写业务系统
缺点:
- 本身比较吃内存
- 在运行 gc 会导致延迟
- gc 触发的时机不可预测
- 内存可能不会在第一时间被释放，那么内存利用率就不高

有些语言需要程序编写者自己管理内存释放，例如 c/c++
优点：可以对程序的内存管理有最精细的控制，适合编写对性能要求较高的模块
缺点:
- 经常会犯忘记释放内存，对一块内存重复释放，访问空指针等问题，不过 c++ 的智能指针可以一定程度缓解这些问题
- 一旦发生错误的内存访问和内存泄漏，对于应用和系统可能是致命的
- 手动管理内存太费脑

rust 没有采用 gc, 也没有完全把管理内存的责任丢给程序员，而是采用了另外的方式：所有权机制
rust 最大语言特色就是所有权机制，运行时零开销，编译期间就能检查出内存安全问题
*/

fn main() {
    // ------------------------ 栈内存与堆内存 -----------------------------
    /*
     存放内容：
     栈内存：用于存放大小已知且大小固定的值，后进先出
     堆内存：用于存放大小未知或大小不固定的值

     内存中的存在形式:
      - 栈内存值是连续存放的，后进先出
      - 堆内存在内存是不连续，散乱的，访问一个堆内存的值可能需要在内存中多次跳转访问

     分配内存速度：
      - 栈更快，因为就是放栈顶，位置固定
      - 堆更慢：因为需要先向系统申请内存中没有被使用的一块大小足够的内存，标记为已使用，再清理那块内存

     访问速度：
      - 栈内存更快，因为内存连续
      - 堆内存更慢，因为可能需要多次跳转
     */

     // ------------------------ 所有权规则 -----------------------------
     // Each value in Rust has a variable that called it's owner
     // There can only be one owner at a time
     // When the owner goes out of scoop, the value will be dropped

}
