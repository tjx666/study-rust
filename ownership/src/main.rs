/*
由于计算机的内存是有限的，因此一个程序需要管理好内存，避免资源占用过高和内存泄漏

有些语言是有 gc 管理内存，例如 java/go
优点：程序员不用操行内存管理，适合写业务系统
缺点:
- 本身比较吃内存
- 在运行 gc 会导致延迟
- gc 触发的时机不可预测
- 内存可能不会在第一时间被释放，那么内存利用率就不高

有些语言需要程序编写者自己管理内存释放，例如 c/c++
优点：可以对程序的内存管理有最精细的控制，适合编写对性能要求较高的模块
缺点:
- 经常会犯忘记释放内存，对一块内存重复释放，访问空指针等问题，不过 c++ 的智能指针可以一定程度缓解这些问题
- 一旦发生错误的内存访问和内存泄漏，对于应用和系统可能是致命的
- 手动管理内存太费脑

rust 没有采用 gc, 也没有完全把管理内存的责任丢给程序员，而是采用了另外的方式：所有权机制
rust 最大语言特色就是所有权机制，运行时零开销，编译期间就能检查出内存安全问题
*/

#[allow(unused)]

fn main() {
    // ------------------------ 栈内存与堆内存 -----------------------------
    /*
    存放内容：
    栈内存：用于存放大小已知且大小固定的值，后进先出
    堆内存：用于存放大小未知或大小不固定的值

    内存中的存在形式:
     - 栈内存值是连续存放的，后进先出
     - 堆内存在内存是不连续，散乱的，访问一个堆内存的值可能需要在内存中多次跳转访问

    分配内存速度：
     - 栈更快，因为就是放栈顶，位置固定
     - 堆更慢：因为需要先向系统申请内存中没有被使用的一块大小足够的内存，标记为已使用，再清理那块内存

    访问速度：
     - 栈内存更快，因为内存连续
     - 堆内存更慢，因为可能需要多次跳转
    */

    // ------------------------ 所有权规则 -----------------------------
    // Each value in Rust has a variable that called it's owner
    // There can only be one owner at a time
    // When the owner goes out of scoop, the value will be dropped

    // ------------------------ str 和 String 类型 -----------------------------
    // 字符串字面量是编译时就知道其内容，所以文本被直接硬编码进最终的可执行文件中，内容和大小都不可变的，类型名是 str
    let str = "字符串字面量";

    // String 类型内存是内容和大小都可变的，放在队内存上
    let string = String::from("String 类型实例");

    // ------------------------ 移动 -----------------------------
    // 声明不可变变量 x，并使用 i32 类型的 5 初始化 x，将 5 压入栈内存
    let x = 5;
    // 复制 x 指向的栈内存，再压入栈内存
    let y = x;

    // 申请了栈内存存放 s1 的成员
    // 申请堆内存存放 s1.ptr 指向的字符串字节
    // s1 的长度表示的是字符串内容的长度，容量表示申请的内存大小，和 c++ 的 vector 一样，容量是会动态调节的
    let s1 = String::from("hello");
    // 在 js, java 等语言我们会称之为浅拷贝，只是引用复制，指向的内存没有被复制
    // 不同的是由于所有权规则第二条，一个时刻一个值只有一个 owner，这里的 s1 其实会失效，s2 变成 owner
    // 这种行为叫 move，move 其实还确保了多个变量指向同一块内存，离开作用域时不会多次释放
    let s2 = s1;
    // 报错：借用了已经被移动的变量
    // println!("{}", s1);

    // ------------------------ 克隆 -----------------------------
    // 其实也就是深拷贝
    let s3 = s2.clone();
    // 深拷贝后还可以继续使用 s2
    println!("{}", s2);

    let tup1 = (0, 0);
    let tup2 = tup1;
    // 还是可以访问 tup1，因为 (i32, i32) 类型实现了 copy trait
    println!("{}", tup1.1);
    // 如果一个类型实现了 Copy trait，那么一个旧的变量在将其赋值给其他变量后仍然可用。
    // Rust 不允许自身或其任何部分实现了 Drop trait 的类型使用 Copy trait。
    // 任何简单的标量和标量的组合都实现了 copy trait

    let str_tup1 = (1, String::from("666"));
    let str_tup2 = str_tup1;
    // 报错，str_tup1 实现了 drop trait 所以不能实现 copy trait
    // println!("{}", str_tup1.0);

    // ------------------------ 所有权与函数 -----------------------------
    // 函数传参其实和赋值是一样的行为，可能会发生赋值或者移动
    fn add(a: i32, b: i32) -> i32 {
        a + b
    }
    let a = 1;
    let b = 2;
    // 存放栈上的变量 a, b 都是发生赋值
    add(a, b);

    fn print_length(s: String) {
        println!("{}", s);
    }

    let ss = String::from("ss");
    print_length(ss);
    // 报错，ss 在上面传参的时候已经发生了移动
    // println!("{}", ss);

    // 函数返回值也可以发生移动
    fn borrow_then_back(s: String) -> String {
        s
    }

    let ss1 = String::from("ss1");
    // 这里发生了啥？
    // 1. 将 ss1 所有权转移给了 函数参数 s, ss1 失效
    // 2. 通过函数返回值把借出去的所有权还回给了 ss2
    let ss2 = borrow_then_back(ss1);

    // 我们可以使用元组来返回多个值
    fn get_origin() -> (i32, i32) {
        (0, 0)
    }
}
